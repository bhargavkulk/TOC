<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>NFAs in Coq</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-floating"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.2. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="nfas-in-coq">
<h1 class="title">NFAs in Coq</h1>

<style>
  .highlight, .code .hll {
    background-color: #ffffff;
  }

  .alectryon-coqdoc .doc .code, .alectryon-coqdoc .doc .comment,
  .alectryon-coqdoc .doc .inlinecode, .alectryon-mref, .alectryon-block,
  .alectryon-io, .alectryon-toggle-label, .alectryon-banner {
    font-family: 'Fira Code', monospace;
  }
</style><div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#computation" id="toc-entry-1">Computation</a></li>
<li><a class="reference internal" href="#acceptance-for-nfas" id="toc-entry-2">Acceptance for NFAs</a></li>
<li><a class="reference internal" href="#equivalence-of-dfas-and-nfas" id="toc-entry-3">Equivalence of DFAs and NFAs</a><ul>
<li><a class="reference internal" href="#dfa-longrightarrow-nfa" id="toc-entry-4">DFA <span class="math">\(\longrightarrow\)</span> NFA</a></li>
<li><a class="reference internal" href="#nfa-longrightarrow-dfa" id="toc-entry-5">NFA <span class="math">\(\longrightarrow\)</span> DFA</a></li>
</ul>
</li>
</ul>
</div>
<p>NFAs are defined as a 5-tuples; A NFA <span class="math">\(M\)</span> is defined as 
<span class="math">\((Q, \Sigma, s, F, \delta)\)</span>, where:</p>
<dl class="docutils">
<dt><span class="math">\(Q\)</span></dt>
<dd>is the finite set of states.</dd>
<dt><span class="math">\(\Sigma\)</span></dt>
<dd>is the finite set of input symbols, also called the alphabet.</dd>
<dt><span class="math">\(\delta : Q \times \Sigma \to Q\)</span></dt>
<dd>is the transition function.</dd>
<dt><span class="math">\(s \in Q\)</span></dt>
<dd>is the initial or start state.</dd>
<dt><span class="math">\(F \subseteq Q\)</span></dt>
<dd>is the set of final or accept states.</dd>
</dl>
<div class="section" id="computation">
<h1><a class="toc-backref" href="#toc-entry-1">Computation</a></h1>
<p>Computation is defined here again using the <span class="math">\(\delta^*\)</span> function:</p>
<div class="math">
\begin{align*}
&amp;\delta^* : Q \times \Sigma^* \to \mathcal{P}(Q) \\
&amp;\delta^*(q, \varepsilon) = \{q\} \\
&amp;\delta^*(q, x \cdot w') = \bigcup_{s \in \delta(q, x)}\delta^* (s, w)
\end{align*}
</div>
<p>This function intuitively computes the list of possible states that the NFA 
could land on given a certain input string and a starting state. This is 
defined in Coq as:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">ndelta_star</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">q</span> <span class="nv">w</span> :=
<span class="kr">match</span> w <span class="kr">with</span>
| []      =&gt; [q]
| x :: w&#39; =&gt; flat_map (<span class="kr">fun</span> <span class="nv">p</span> =&gt; ndelta_star M p w&#39;) (nŒ¥ M q x)
<span class="kr">end</span>.</span></span></pre><p>The following theorem, <code class="highlight coq"><span class="n">ndelta_step</span></code> is similiar to the <code class="highlight coq"><span class="n">delta_step</span></code> 
theorem proved for <a class="reference external" href="DFA.html">DFAs</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">ndelta_step</span> <span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kr">forall</span> (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">w</span> <span class="nv">x</span> <span class="nv">q</span>,
  ndelta_star M q (w ++ [x]) 
    = flat_map (<span class="kr">fun</span> <span class="nv">p</span> =&gt; nŒ¥ M p x) (ndelta_star M q w).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : nfa Q Œ£) (<span class="nv">w</span> : list Œ£) (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk1"><span class="nb">intros</span> M w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2"><span class="nb">induct</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) (nŒ¥ M q x) =
nŒ¥ M q x ++ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nfa-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="nfa-v-chk3"><hr></label><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x]))
  (nŒ¥ M q a) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
  (flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p w)
     (nŒ¥ M q a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) (nŒ¥ M q x) =
nŒ¥ M q x ++ []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk5"><span class="nb">rewrite</span> app_nil_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) (nŒ¥ M q x) = nŒ¥ M q x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk6"><span class="nb">generalize</span> (nŒ¥ M q x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list Q, flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk7"><span class="nb">induct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk9"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; [p]) l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x]))
  (nŒ¥ M q a) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
  (flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p w)
     (nŒ¥ M q a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chkb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x]))
  (nŒ¥ M q a) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
  (flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p w)
     (nŒ¥ M q a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="nfa-v-chkc" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">flat_map_comp
     : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : B -&gt; list C)
         (<span class="nv">g</span> : A -&gt; list B) (<span class="nv">l</span> : list A),
       flat_map f (flat_map g l) =
       flat_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; flat_map f (g x)) l</blockquote></div></div></small></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chkd"><span class="nb">rewrite</span> flat_map_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x]))
  (nŒ¥ M q a) =
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) (nŒ¥ M q a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chke"><span class="nb">generalize</span> (nŒ¥ M q a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list Q,
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chkf"><span class="nb">induct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a0</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map
(<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt; flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M x0 w)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ndelta_star M a0 (w ++ [x]) ++
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M a0 w) ++
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk10">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a0</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map
(<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt; flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M x0 w)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ndelta_star M a0 (w ++ [x]) ++
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M a0 w) ++
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk11"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a0</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map
(<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt; flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M x0 w)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ndelta_star M a0 (w ++ [x]) ++
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M a0 w) ++
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk12"><span class="nb">rewrite</span> IHw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : Œ£) (<span class="nv">q</span> : Q),
ndelta_star M q (w ++ [x]) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M q w)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>q, a0</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Q</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; ndelta_star M p (w ++ [x])) l =
flat_map
(<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt; flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M x0 w)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M a0 w) ++
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x) (ndelta_star M a0 w) ++
flat_map
  (<span class="kr">fun</span> <span class="nv">x0</span> : Q =&gt;
   flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
     (ndelta_star M x0 w)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="acceptance-for-nfas">
<h1><a class="toc-backref" href="#toc-entry-2">Acceptance for NFAs</a></h1>
<p>Acceptance of a word <span class="math">\(w\)</span> by a nfa <span class="math">\(M\)</span> is as simple as checking if
there exists a state <span class="math">\(q \in \delta^*(s, w)\)</span> such that, <span class="math">\(q \in F\)</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nacceptb</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">word</span> : bool :=
  existsb M.(nF) (ndelta_star M M.(ns) word).</span></span></pre></div>
<div class="section" id="equivalence-of-dfas-and-nfas">
<h1><a class="toc-backref" href="#toc-entry-3">Equivalence of DFAs and NFAs</a></h1>
<p>To show that DFAs and NFAs are equally <em>powerful</em>, we only need to convert one 
to other and vice-versa, and show that the conversion is correct.</p>
<div class="section" id="dfa-longrightarrow-nfa">
<h2><a class="toc-backref" href="#toc-entry-4">DFA <span class="math">\(\longrightarrow\)</span> NFA</a></h2>
<p>Given a dfa <span class="math">\(M\)</span>, the corresponding NFA <span class="math">\(N\)</span> is defined as:</p>
<ul class="simple">
<li><span class="math">\(Q_N = Q_M\)</span></li>
<li><span class="math">\(s_N = s_M\)</span></li>
<li><span class="math">\(F_N = F_M\)</span></li>
<li><span class="math">\(\delta_N(p, x) = \{\delta_M(p, x)\}\)</span></li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DfaToNfa</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dfa_to_nfa</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : dfa Q Œ£) : nfa Q Œ£ := {| 
    nstates := M.(states);
    nchar := M.(char);
    ns := M.(s);
    nF := M.(F);
    nŒ¥ := <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">x</span> =&gt; [M.(Œ¥) p x]; 
  |}.</span></span></pre><p>As we did for the the proofs for <a class="reference external" href="DFA.html">DFAs</a>, we prove a mirroring 
lemma...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">dfa_to_nfa_step</span> <span class="nv">Q</span> <span class="nv">Œ£</span>: <span class="kr">forall</span> (<span class="nv">M</span> : dfa Q Œ£) <span class="nv">w</span> <span class="nv">q</span>,
    [delta_star M q w] = ndelta_star (dfa_to_nfa M) q w.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : dfa Q Œ£) (<span class="nv">w</span> : list Œ£) (<span class="nv">q</span> : Q),
[delta_star M q w] = ndelta_star (dfa_to_nfa M) q w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk14"><span class="nb">induct&#39;</span> w rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">q</span> : Q, [delta_star M q w] = ndelta_star (dfa_to_nfa M) q w</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[delta_star M q (w ++ [x])] =
ndelta_star (dfa_to_nfa M) q (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="nfa-v-chk15" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">delta_step
     : <span class="kr">forall</span> (<span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kt">Type</span>) (<span class="nv">M</span> : dfa Q Œ£) (<span class="nv">w</span> : list Œ£)
         (<span class="nv">p</span> : Q) (<span class="nv">x</span> : Œ£),
       delta_star M p (w ++ [x]) =
       Œ¥ M (delta_star M p w) x</blockquote></div></div></small></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> delta_step, ndelta_step, &lt;- IHw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>...and then prove our ocnstruction is correct.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">dfa_to_nfa_correct</span> <span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kr">forall</span> (<span class="nv">M</span> : dfa Q Œ£) <span class="nv">w</span>,
    acceptb M w = true 
      &lt;-&gt; nacceptb (dfa_to_nfa M) w = true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : dfa Q Œ£) (<span class="nv">w</span> : list Œ£),
acceptb M w = true &lt;-&gt;
nacceptb (dfa_to_nfa M) w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk17"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb M w = true &lt;-&gt;
nacceptb (dfa_to_nfa M) w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk18"><span class="nb">unfold</span> acceptb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) w) = true &lt;-&gt;
nacceptb (dfa_to_nfa M) w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk19"><span class="nb">unfold</span> nacceptb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
  (ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk1a"><span class="nb">induct&#39;</span> w rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (s M) = true &lt;-&gt; F M (s M) || false = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nfa-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
(ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) = true</span></span></span><br></div><label class="goal-separator" for="nfa-v-chk1b"><hr></label><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true &lt;-&gt;
existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (s M) = true &lt;-&gt; F M (s M) || false = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk1d"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (s M) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (s M) || false = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nfa-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (s M) || false = true</span></span></span><br></div><label class="goal-separator" for="nfa-v-chk1e"><hr></label><div class="goal-conclusion">F M (s M) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk1f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (s M) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (s M) || false = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="nfa-v-chk20" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">orb_false_r
     : <span class="kr">forall</span> <span class="nv">b</span> : bool, b || false = b</blockquote></div></div></small></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (s M) || false = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (s M) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="kp">repeat</span> <span class="nb">rewrite</span> orb_false_r <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk22">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
(ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true &lt;-&gt;
existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk23"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
(ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nfa-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
(ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) =
true</span></span></span><br></div><label class="goal-separator" for="nfa-v-chk24"><hr></label><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk25">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
(ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk26"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (F M) (ndelta_star (dfa_to_nfa M) (s M) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk27"><span class="nb">rewrite</span> &lt;- dfa_to_nfa_step <span class="kr">in</span> IHw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (F M) [delta_star M (s M) w] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk28"><span class="nb">rewrite</span> &lt;- dfa_to_nfa_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (F M) [delta_star M (s M) w] = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb (F M) [delta_star M (s M) (w ++ [x])] = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk29"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
F M (delta_star M (s M) w) || false = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) || false = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> orb_false_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (nF (dfa_to_nfa M))
(ndelta_star (dfa_to_nfa M) (ns (dfa_to_nfa M)) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2b"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (F M) (ndelta_star (dfa_to_nfa M) (s M) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>existsb (F M)
  (ndelta_star (dfa_to_nfa M) (s M) (w ++ [x])) =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2c"><span class="nb">rewrite</span> &lt;- dfa_to_nfa_step <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (F M) (ndelta_star (dfa_to_nfa M) (s M) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>existsb (F M) [delta_star M (s M) (w ++ [x])] =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2d"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) w) = true &lt;-&gt;
existsb (F M) (ndelta_star (dfa_to_nfa M) (s M) w) = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>F M (delta_star M (s M) (w ++ [x])) || false =
true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F M (delta_star M (s M) (w ++ [x])) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="kp">repeat</span> <span class="nb">rewrite</span> orb_false_r <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DfaToNfa</span>.</span></span></pre></div>
<div class="section" id="nfa-longrightarrow-dfa">
<h2><a class="toc-backref" href="#toc-entry-5">NFA <span class="math">\(\longrightarrow\)</span> DFA</a></h2>
<p>This construction, also called the powerset construction is a bit more involved.
Here on, <span class="math">\(N\)</span> is a NFA and <span class="math">\(M\)</span> is the DFA constructed from <span class="math">\(N\)</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">NfaToDfa</span>.</span></span></pre><p>Firstly, <span class="math">\(Q_M = \mathcal{P}(Q_N)\)</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">powerset_states</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : nfa Q Œ£) := 
    powerset M.(nstates).</span></span></pre><p>Then, <span class="math">\(F_M = \{q \subseteq \mathcal{P}(Q) \mid \exists p \in q, p \in F_N\}\)</span></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">powerset_F</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">q</span> :=
    existsb M.(nF) q.</span></span></pre><p>Then, <span class="math">\(\delta_M = \bigcup_{p \in q}\delta_N(p, x)\)</span></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">powerset_delta</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">q</span> <span class="nv">x</span> :=
    flat_map (<span class="kr">fun</span> <span class="nv">s</span> =&gt; M.(nŒ¥) s x) q.</span></span></pre><p>And with that we can construct a DFA from an NFA.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">powerset_dfa</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : nfa Q Œ£) 
    : dfa (list Q) Œ£ := {|
    states := powerset_states M;
    char := M.(nchar);
    s := [M.(ns)];
    F := powerset_F M;
    Œ¥ := powerset_delta M;
  |}.</span></span></pre><p>We then prove the mirroring lemma...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">powerset_dfa_step</span> <span class="nv">Q</span> <span class="nv">Œ£</span>: <span class="kr">forall</span> (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">w</span>,
    delta_star (powerset_dfa M) (powerset_dfa M).(s) w 
      = ndelta_star M M.(ns) w.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : nfa Q Œ£) (<span class="nv">w</span> : list Œ£),
delta_star (powerset_dfa M) (s (powerset_dfa M)) w =
ndelta_star M (ns M) w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk2f"><span class="nb">induct&#39;</span> w rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (powerset_dfa M) (s (powerset_dfa M)) w = ndelta_star M (ns M) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star (powerset_dfa M) [ns M] (w ++ [x]) =
ndelta_star M (ns M) (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (powerset_dfa M) (s (powerset_dfa M)) w = ndelta_star M (ns M) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star (powerset_dfa M) [ns M] (w ++ [x]) =
ndelta_star M (ns M) (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk31"><span class="nb">rewrite</span> delta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (powerset_dfa M) (s (powerset_dfa M)) w = ndelta_star M (ns M) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ (powerset_dfa M)
  (delta_star (powerset_dfa M) [ns M] w) x =
ndelta_star M (ns M) (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk32"><span class="nb">rewrite</span> ndelta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (powerset_dfa M) (s (powerset_dfa M)) w = ndelta_star M (ns M) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ (powerset_dfa M)
  (delta_star (powerset_dfa M) [ns M] w) x =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
  (ndelta_star M (ns M) w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk33"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (powerset_dfa M) [ns M] w = ndelta_star M (ns M) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">powerset_delta M
  (delta_star (powerset_dfa M) [ns M] w) x =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
  (ndelta_star M (ns M) w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk34"><span class="nb">unfold</span> powerset_delta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (powerset_dfa M) [ns M] w = ndelta_star M (ns M) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flat_map (<span class="kr">fun</span> <span class="nv">s</span> : Q =&gt; nŒ¥ M s x)
  (delta_star (powerset_dfa M) [ns M] w) =
flat_map (<span class="kr">fun</span> <span class="nv">p</span> : Q =&gt; nŒ¥ M p x)
  (ndelta_star M (ns M) w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>...then prove the correctness of the construction.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">powerset_dfa_correct</span> <span class="nv">Q</span> <span class="nv">Œ£</span>: <span class="kr">forall</span> (<span class="nv">M</span> : nfa Q Œ£) <span class="nv">w</span>,
    acceptb (powerset_dfa M) w = true &lt;-&gt; nacceptb M w = true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M</span> : nfa Q Œ£) (<span class="nv">w</span> : list Œ£),
acceptb (powerset_dfa M) w = true &lt;-&gt;
nacceptb M w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk36"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb (powerset_dfa M) w = true &lt;-&gt;
nacceptb M w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk37"><span class="nb">unfold</span> acceptb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F (powerset_dfa M)
  (delta_star (powerset_dfa M) (s (powerset_dfa M)) w) =
true &lt;-&gt; nacceptb M w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk38"><span class="nb">unfold</span> nacceptb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F (powerset_dfa M)
  (delta_star (powerset_dfa M) (s (powerset_dfa M)) w) =
true &lt;-&gt;
existsb (nF M) (ndelta_star M (ns M) w) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk39"><span class="nb">induct&#39;</span> w rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F (powerset_dfa M) (delta_star (powerset_dfa M) (s (powerset_dfa M)) w) =
true &lt;-&gt; existsb (nF M) (ndelta_star M (ns M) w) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">powerset_F M
  (delta_star (powerset_dfa M) [ns M] (w ++ [x])) =
true &lt;-&gt;
existsb (nF M) (ndelta_star M (ns M) (w ++ [x])) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F (powerset_dfa M) (delta_star (powerset_dfa M) (s (powerset_dfa M)) w) =
true &lt;-&gt; existsb (nF M) (ndelta_star M (ns M) w) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">powerset_F M
  (delta_star (powerset_dfa M) [ns M] (w ++ [x])) =
true &lt;-&gt;
existsb (nF M) (ndelta_star M (ns M) (w ++ [x])) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nfa-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="nfa-v-chk3b"><span class="nb">unfold</span> powerset_F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>nfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>F (powerset_dfa M) (delta_star (powerset_dfa M) (s (powerset_dfa M)) w) =
true &lt;-&gt; existsb (nF M) (ndelta_star M (ns M) w) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb (nF M)
  (delta_star (powerset_dfa M) [ns M] (w ++ [x])) =
true &lt;-&gt;
existsb (nF M) (ndelta_star M (ns M) (w ++ [x])) =
true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> powerset_dfa_step.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">NfaToDfa</span>.</span></span></pre><p>Back to <a class="reference external" href="index.html">project index</a>.</p>
</div>
</div>
</div>
</div></body>
</html>
