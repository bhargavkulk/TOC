<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>DFAs in Coq</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.2. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="dfas-in-coq">
<h1 class="title">DFAs in Coq</h1>

<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#computation" id="toc-entry-1">Computation</a></li>
<li><a class="reference internal" href="#acceptance-for-dfas" id="toc-entry-2">Acceptance for DFAs</a></li>
<li><a class="reference internal" href="#complement-of-a-dfa" id="toc-entry-3">Complement of a DFA</a></li>
<li><a class="reference internal" href="#product-construction-intersection-and-union" id="toc-entry-4">Product Construction: Intersection and Union</a></li>
</ul>
</div>
<p>DFAs are defined as a 5-tuples; A DFA <span class="math">\(M\)</span> is defined as 
<span class="math">\((Q, \Sigma, s, F, \delta)\)</span>, where:</p>
<dl class="docutils">
<dt><span class="math">\(Q\)</span></dt>
<dd>is the finite set of states.</dd>
<dt><span class="math">\(\Sigma\)</span></dt>
<dd>is the finite set of input symbols, also called the alphabet.</dd>
<dt><span class="math">\(\delta : Q \times \Sigma \to Q\)</span></dt>
<dd>is the transition function.</dd>
<dt><span class="math">\(s \in Q\)</span></dt>
<dd>is the initial or start state.</dd>
<dt><span class="math">\(F \subseteq Q\)</span></dt>
<dd>is the set of final or accept states.</dd>
</dl>
<p>The Coq formalization is as follows:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">dfa</span> (<span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kt">Type</span>) := {
  states : list Q;
  char : list Œ£;
  s : Q;
  F : Q -&gt; bool;
  Œ¥ : Q -&gt; Œ£ -&gt; Q;
}.</span></span></pre><p><code class="highlight coq"><span class="kt">Type</span></code> is effectively infinite, so finiteness is ensured by also asking 
for a list of the states and characters of the alphabet. As a notion of finite 
sets has not been developed in this project, the notion of being a final state 
is defined as a boolean predicate; if <code class="highlight coq"><span class="n">M</span><span class="o">.(</span><span class="n">F</span><span class="o">)</span> <span class="n">q</span></code> is <code class="highlight coq"><span class="n">true</span></code> then 
it is a final state, else it is not.</p>
<div class="section" id="computation">
<h1><a class="toc-backref" href="#toc-entry-1">Computation</a></h1>
<p>Computation is defined here using the <span class="math">\(\delta^*\)</span> function which is
defined in Coq as <code class="highlight coq"><span class="n">delta_star</span></code>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">delta_star</span> {<span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kt">Type</span>} (<span class="nv">M</span> : dfa Q Œ£) (<span class="nv">p</span> : Q) (<span class="nv">x</span> : list Œ£) :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | [] =&gt; p
  | x :: xs =&gt; delta_star M (M.(Œ¥) p x) xs
<span class="kr">end</span>.</span></span></pre><p>Some properties about <span class="math">\(\delta^*\)</span> are now proved.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DeltaStar</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> <span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">M</span> : dfa Q Œ£.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">delta_cons</span> : <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">a</span> <span class="nv">x</span>, 
    delta_star M (Œ¥ M p a) x = delta_star M p (a :: x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">delta_cat</span> : <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">x</span> <span class="nv">y</span>,
    delta_star M p (x ++ y) = delta_star M (delta_star M p x) y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> p x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk0">gendep p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : Q) (<span class="nv">y</span> : list Œ£),
delta_star M p (x ++ y) =
delta_star M (delta_star M p x) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk1"><span class="nb">induct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : Q) (<span class="nv">y</span> : list Œ£),
delta_star M p (x ++ y) = delta_star M (delta_star M p x) y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star M (Œ¥ M p a) (x ++ y) =
delta_star M (delta_star M (Œ¥ M p a) x) y</div></blockquote></div></div></small></span></pre><p>The <code class="highlight coq"><span class="n">induct</span></code> tactic is a custom tactic which tries to discharge the base 
case, because most base cases in induction proofs are easily solvablw with 
basic tactics. As you can see here, <code class="highlight coq"><span class="n">induct</span> <span class="n">x</span></code> skips the base case, and
moves on to the inductive case.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk2"><span class="nb">rewrite</span> IHx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : Q) (<span class="nv">y</span> : list Œ£),
delta_star M p (x ++ y) = delta_star M (delta_star M p x) y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star M (delta_star M (Œ¥ M p a) x) y =
delta_star M (delta_star M (Œ¥ M p a) x) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">delta_single</span>: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">a</span>,
      M.(Œ¥) p a = delta_star M p [a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The following theorem, <code class="highlight coq"><span class="n">delta_step</span></code> is important for future proofs. It is 
also another way to look at the <span class="math">\(\delta^*\)</span> function.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">delta_step</span>: <span class="kr">forall</span> <span class="nv">w</span> <span class="nv">p</span> <span class="nv">x</span>,
    delta_star M p (w ++ [x]) = M.(Œ¥) (delta_star M p w) x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk3"><span class="nb">induct</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : Q) (<span class="nv">x</span> : Œ£), delta_star M p (w ++ [x]) = Œ¥ M (delta_star M p w) x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star M (Œ¥ M p a) (w ++ [x]) =
Œ¥ M (delta_star M (Œ¥ M p a) w) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk4"><span class="nb">rewrite</span> IHw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">p</span> : Q) (<span class="nv">x</span> : Œ£), delta_star M p (w ++ [x]) = Œ¥ M (delta_star M p w) x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ M (delta_star M (Œ¥ M p a) w) x =
Œ¥ M (delta_star M (Œ¥ M p a) w) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DeltaStar</span>.</span></span></pre></div>
<div class="section" id="acceptance-for-dfas">
<h1><a class="toc-backref" href="#toc-entry-2">Acceptance for DFAs</a></h1>
<p>Acceptance of a word <span class="math">\(w\)</span> by a dfa <span class="math">\(M\)</span> is as simple as checking if 
<span class="math">\(\delta^*(s, w) \in F\)</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">acceptb</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span> : dfa Q Œ£) <span class="nv">word</span> : bool :=
  M.(F) (delta_star M M.(s) word).</span></span></pre></div>
<div class="section" id="complement-of-a-dfa">
<h1><a class="toc-backref" href="#toc-entry-3">Complement of a DFA</a></h1>
<p>The complement construction of a DFA is very simpl. You only need to turn final 
states into non-final states and vice-versa. This is achieved in Coq by 
performing the boolean negation of <code class="highlight coq"><span class="n">M</span><span class="o">.(</span><span class="n">F</span><span class="o">)</span></code></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Complement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compl_dfa</span> {<span class="nv">Q</span> <span class="nv">Œ£</span>} (<span class="nv">M</span>: dfa Q Œ£): dfa Q Œ£ := {|
    states := M.(states);
    char := M.(char);
    s := M.(s);
    F := <span class="kr">fun</span> <span class="nv">x</span> =&gt; negb (M.(F) x);
    Œ¥ := M.(Œ¥);
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> <span class="nv">Q</span> <span class="nv">Œ£</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">M</span> : dfa Q Œ£.</span></span></pre><p>The lemma that follows is a <strong>mirorring</strong> lemma. It shows how both the original 
DFA and the complement DFA <em>move</em> together or <em>mirror</em> each other i.e. for the 
same input string, the complement DFA <strong>must</strong> land on the same state as the 
original DFA, provided we start from the same state.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">compl_dfa_step</span>: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">w</span>,
    delta_star M p w = delta_star (compl_dfa M) p w.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk5"><span class="nb">induct&#39;</span> w rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star M p w = delta_star (compl_dfa M) p w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star M p (w ++ [x]) =
delta_star (compl_dfa M) p (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk6"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star M p w = delta_star (compl_dfa M) p w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star M p (w ++ [x]) =
delta_star (compl_dfa M) p (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk7"><span class="nb">rewrite</span> delta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star M p w = delta_star (compl_dfa M) p w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ M (delta_star M p w) x =
delta_star (compl_dfa M) p (w ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk8"><span class="nb">rewrite</span> delta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star M p w = delta_star (compl_dfa M) p w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ M (delta_star M p w) x =
Œ¥ (compl_dfa M) (delta_star (compl_dfa M) p w) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk9"><span class="nb">rewrite</span> IHw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star M p w = delta_star (compl_dfa M) p w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ M (delta_star (compl_dfa M) p w) x =
Œ¥ (compl_dfa M) (delta_star (compl_dfa M) p w) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We can then use this lemma to prove that our complement DFA constructions is 
actually correct i.e. 
<span class="math">\(w \in L(M) \longleftrightarrow w \notin L(\overline M)\)</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">compl_dfa_correct</span>: <span class="kr">forall</span> <span class="nv">w</span>,
    acceptb M w = true &lt;-&gt; acceptb (compl_dfa M) w = false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chka"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>dfa Q Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb M w = true &lt;-&gt; acceptb (compl_dfa M) w = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> acceptb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">rewrite</span> compl_dfa_step;
         <span class="nb">simpl</span>;
         <span class="nb">apply</span> Bool.negb_false_iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Complement</span>.</span></span></pre></div>
<div class="section" id="product-construction-intersection-and-union">
<h1><a class="toc-backref" href="#toc-entry-4">Product Construction: Intersection and Union</a></h1>
<p>The intersection of two DFAs is now defined. Given DFAs <span class="math">\(M_1\)</span> and 
<span class="math">\(M_2\)</span> with the same <span class="math">\(\Sigma\)</span> we can define the intersection DFA 
<span class="math">\(M_\cap\)</span> as:</p>
<ul class="simple">
<li><span class="math">\(Q_\cap = Q_1 \times Q_2\)</span></li>
<li><span class="math">\(s_\cap = (s_1, s_2)\)</span></li>
<li><span class="math">\(F_\cap = F_1 \cap F_2\)</span> i.e. <span class="math">\((q_1, q_2) \in F_\cap \longleftrightarrow q_1 \in F_1 \wedge q_2 \in F_2\)</span></li>
<li><span class="math">\(\delta_\cap(q_1, q_2) = (\delta_1(q_1), \delta_2(q_2))\)</span></li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Product</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">inters_dfa</span> {<span class="nv">Q_1</span> <span class="nv">Q_2</span> <span class="nv">Œ£</span>} (<span class="nv">M_1</span>: dfa Q_1 Œ£) (<span class="nv">M_2</span>: dfa Q_2 Œ£) :
dfa (Q_1 * Q_2) Œ£ := {|
  states := cross_product (states M_1) (states M_2);
  char := (char M_1);
  s := (s M_1, s M_2);
  F := <span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="kr">match</span> p <span class="kr">with</span> (a, c) =&gt; (F M_1 a) &amp;&amp; (F M_2 c) <span class="kr">end</span>;
  Œ¥ := <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">x</span> =&gt; <span class="kr">match</span> p <span class="kr">with</span> (a, c) =&gt; (Œ¥ M_1 a x, Œ¥ M_2 c x) <span class="kr">end</span>;
|}.</span></span></pre><p>What follows is the mirroring lemma for the intersection DFA...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">inters_dfa_step</span> <span class="nv">Q_1</span> <span class="nv">Q_2</span> <span class="nv">Œ£</span>:
  <span class="kr">forall</span> (<span class="nv">M_1</span>: dfa Q_1 Œ£) (<span class="nv">M_2</span>: dfa Q_2 Œ£) <span class="nv">p</span> <span class="nv">q</span> <span class="nv">w</span>,
    delta_star (inters_dfa M_1 M_2) (p, q) w 
      = (delta_star M_1 p w, delta_star M_2 q w).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chkb"><span class="nb">induct&#39;</span> w rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q_1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q_2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (inters_dfa M_1 M_2) (p, q) w =
(delta_star M_1 p w, delta_star M_2 q w)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta_star (inters_dfa M_1 M_2) (p, q) (w ++ [x]) =
(delta_star M_1 p (w ++ [x]),
delta_star M_2 q (w ++ [x]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">-</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chkc"><span class="nb">rewrite</span> delta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q_1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q_2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (inters_dfa M_1 M_2) (p, q) w =
(delta_star M_1 p w, delta_star M_2 q w)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ (inters_dfa M_1 M_2)
  (delta_star (inters_dfa M_1 M_2) (p, q) w) x =
(delta_star M_1 p (w ++ [x]),
delta_star M_2 q (w ++ [x]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chkd"><span class="nb">rewrite</span> IHw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q_1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q_2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (inters_dfa M_1 M_2) (p, q) w =
(delta_star M_1 p w, delta_star M_2 q w)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ (inters_dfa M_1 M_2)
  (delta_star M_1 p w, delta_star M_2 q w) x =
(delta_star M_1 p (w ++ [x]),
delta_star M_2 q (w ++ [x]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chke"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q_1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q_2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (inters_dfa M_1 M_2) (p, q) w =
(delta_star M_1 p w, delta_star M_2 q w)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ M_1 (delta_star M_1 p w) x,
Œ¥ M_2 (delta_star M_2 q w) x) =
(delta_star M_1 p (w ++ [x]),
delta_star M_2 q (w ++ [x]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chkf"><span class="nb">rewrite</span> delta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q_1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q_2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (inters_dfa M_1 M_2) (p, q) w =
(delta_star M_1 p w, delta_star M_2 q w)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ M_1 (delta_star M_1 p w) x,
Œ¥ M_2 (delta_star M_2 q w) x) =
(Œ¥ M_1 (delta_star M_1 p w) x,
delta_star M_2 q (w ++ [x]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk10"><span class="nb">rewrite</span> delta_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q_1</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q_2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>delta_star (inters_dfa M_1 M_2) (p, q) w =
(delta_star M_1 p w, delta_star M_2 q w)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ M_1 (delta_star M_1 p w) x,
Œ¥ M_2 (delta_star M_2 q w) x) =
(Œ¥ M_1 (delta_star M_1 p w) x,
Œ¥ M_2 (delta_star M_2 q w) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>...and the correctness of the intersection DFA.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">inters_dfa_correct</span> <span class="nv">Q_1</span> <span class="nv">Q_2</span> <span class="nv">Œ£</span>: 
  <span class="kr">forall</span> (<span class="nv">M_1</span>: dfa Q_1 Œ£) (<span class="nv">M_2</span>: dfa Q_2 Œ£) <span class="nv">w</span>,
  acceptb (inters_dfa M_1 M_2) w = true
    &lt;-&gt; (acceptb M_1 w = true) /\ (acceptb M_2 w = true).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M_1</span> : dfa Q_1 Œ£) (<span class="nv">M_2</span> : dfa Q_2 Œ£)
  (<span class="nv">w</span> : list Œ£),
acceptb (inters_dfa M_1 M_2) w = true &lt;-&gt;
acceptb M_1 w = true /\ acceptb M_2 w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> acceptb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk12"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F (inters_dfa M_1 M_2)
  (delta_star (inters_dfa M_1 M_2)
     (s (inters_dfa M_1 M_2)) w) = true -&gt;
F M_1 (delta_star M_1 (s M_1) w) = true /\
F M_2 (delta_star M_2 (s M_2) w) = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="dfa-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br></div><label class="goal-separator" for="dfa-v-chk13"><hr></label><div class="goal-conclusion">F M_1 (delta_star M_1 (s M_1) w) = true /\
F M_2 (delta_star M_2 (s M_2) w) = true -&gt;
F (inters_dfa M_1 M_2)
  (delta_star (inters_dfa M_1 M_2)
     (s (inters_dfa M_1 M_2)) w) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">simpl</span>;
       <span class="nb">rewrite</span> inters_dfa_step;
       <span class="nb">apply</span> Bool.andb_true_iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The union DFA is defined very easily using DeMorgan's law:</p>
<div class="math">
\begin{equation*}
M_\cup = \overline{\overline{M_1} \cap \overline{M_2}}
\end{equation*}
</div>
<p>, which we define as such in Coq...</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">union_dfa</span> {<span class="nv">Q_1</span> <span class="nv">Q_2</span> <span class="nv">Œ£</span>} (<span class="nv">M_1</span>: dfa Q_1 Œ£) (<span class="nv">M_2</span>: dfa Q_2 Œ£) :=
  compl_dfa (inters_dfa (compl_dfa M_1) (compl_dfa M_2)).</span></span></pre><p>...and then prove its correctness.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">union_dfa_correct</span> <span class="nv">Q_1</span> <span class="nv">Q_2</span> <span class="nv">Œ£</span>:
  <span class="kr">forall</span> (<span class="nv">M_1</span>: dfa Q_1 Œ£) (<span class="nv">M_2</span>: dfa Q_2 Œ£) <span class="nv">w</span>,
  acceptb (union_dfa M_1 M_2) w = true 
    &lt;-&gt; (acceptb M_1 w = true) \/ (acceptb M_2 w = true).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">M_1</span> : dfa Q_1 Œ£) (<span class="nv">M_2</span> : dfa Q_2 Œ£)
  (<span class="nv">w</span> : list Œ£),
acceptb (union_dfa M_1 M_2) w = true &lt;-&gt;
acceptb M_1 w = true \/ acceptb M_2 w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk15"><span class="nb">split</span>; <span class="nb">unfold</span> union_dfa; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb
  (compl_dfa
     (inters_dfa (compl_dfa M_1) (compl_dfa M_2)))
  w = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb M_1 w = true \/ acceptb M_2 w = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="dfa-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb M_1 w = true \/ acceptb M_2 w = true</span></span></span><br></div><label class="goal-separator" for="dfa-v-chk16"><hr></label><div class="goal-conclusion">acceptb
  (compl_dfa
     (inters_dfa (compl_dfa M_1) (compl_dfa M_2))) w =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb
  (compl_dfa
     (inters_dfa (compl_dfa M_1) (compl_dfa M_2)))
  w = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb M_1 w = true \/ acceptb M_2 w = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk18"><span class="nb">apply</span> compl_dfa_correct_corr <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb
  (inters_dfa (compl_dfa M_1) (compl_dfa M_2)) w =
false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb M_1 w = true \/ acceptb M_2 w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk19"><span class="nb">apply</span> inters_dfa_correct_corr <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb (compl_dfa M_1) w = false \/
acceptb (compl_dfa M_2) w = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb M_1 w = true \/ acceptb M_2 w = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H <span class="kr">as</span> [H | H];
    <span class="nb">apply</span> compl_dfa_correct <span class="kr">in</span> H;
    [<span class="nb">left</span> | <span class="nb">right</span>];
    <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb M_1 w = true \/ acceptb M_2 w = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb
  (compl_dfa
     (inters_dfa (compl_dfa M_1) (compl_dfa M_2))) w =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk1b"><span class="nb">apply</span> compl_dfa_correct_corr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb M_1 w = true \/ acceptb M_2 w = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb (inters_dfa (compl_dfa M_1) (compl_dfa M_2)) w =
false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="dfa-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="dfa-v-chk1c"><span class="nb">apply</span> inters_dfa_correct_corr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q_1, Q_2, Œ£</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>M_1</var><span class="hyp-type"><b>: </b><span>dfa Q_1 Œ£</span></span></span><br><span><var>M_2</var><span class="hyp-type"><b>: </b><span>dfa Q_2 Œ£</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list Œ£</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>acceptb M_1 w = true \/ acceptb M_2 w = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">acceptb (compl_dfa M_1) w = false \/
acceptb (compl_dfa M_2) w = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H <span class="kr">as</span> [H | H];
    <span class="nb">apply</span> compl_dfa_correct <span class="kr">in</span> H;
    [<span class="nb">left</span> | <span class="nb">right</span>];
    <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Product</span>.</span></span></pre></div>
</div>
</div></body>
</html>
